<script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>

<script type="text/javascript">
const minDimension = Math.min(window.innerWidth, window.innerHeight);
const cellSize = minDimension / 12; 

const gridSize = 10;
const lineLength = cellSize * 0.6;
const lineThickness = cellSize * 0.06;
const dotSize = cellSize * 0.06;
const padding = cellSize * 0.1;

let avatarX;
let avatarY;
let lastRotationTime = 0;

const config = {
  type: Phaser.AUTO,
  width: window.innerWidth,
  height: window.innerHeight,
  scene: {
    preload: preload,
    create: create,
    update: update
  }
};

const game = new Phaser.Game(config);

function preload() {
  const size = 20;
  const canvasTexture = this.textures.createCanvas('avatar', size, Math.sqrt(3) * size / 2).source[0].image;
  const context = canvasTexture.getContext('2d');
  context.beginPath();
  context.moveTo(size / 2, 0);
  context.lineTo(size, size * Math.sqrt(3) / 2);
  context.lineTo(0, size * Math.sqrt(3) / 2);
  context.closePath();
  context.strokeStyle = 'black';
  context.lineWidth = 2;
  context.stroke();
  context.fillStyle = 'yellow';
  context.fill();
}

function create() {
  this.cameras.main.setBackgroundColor('#ffffff');

  const offsetX = (this.cameras.main.width - (gridSize * cellSize)) / 2;
  const offsetY = (this.cameras.main.height - (gridSize * cellSize)) / 2;

  this.lines = [];

  for (let i = 0; i < gridSize; i++) {
  for (let j = 0; j < gridSize; j++) {
    const x = offsetX + i * cellSize;
    const y = offsetY + j * cellSize;

    const directions = ['N', 'E', 'S', 'W'];
    const direction = directions[Phaser.Math.Between(0, 3)];
    const color = new Phaser.Display.Color();
    color.random(1);

    let line1 = this.add.line(x, y, 0, 0, 0, 0, color.color).setLineWidth(lineThickness).setOrigin(0, 0.5);
    let line2 = this.add.line(x, y, 0, 0, 0, 0, color.color).setLineWidth(lineThickness).setOrigin(0, 0.5);

    switch (direction) {
      case 'N':
        line1.setTo(0, 0, 0, -lineLength);
        line2.setTo(0, 0, lineLength, 0);
        break;
      case 'E':
        line1.setTo(0, 0, lineLength, 0);
        line2.setTo(0, 0, 0, lineLength);
        break;
      case 'S':
        line1.setTo(0, 0, 0, lineLength);
        line2.setTo(0, 0, -lineLength, 0);
        break;
      case 'W':
        line1.setTo(0, 0, -lineLength, 0);
        line2.setTo(0, 0, 0, -lineLength);
        break;
    }

    this.lines.push(line1);
    this.lines.push(line2);
  }
}

  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      const x = offsetX + i * cellSize;
      const y = offsetY + j * cellSize;
      this.add.circle(x, y, dotSize, 0x000000);
    }
  }

  const padding = 10; 

avatarX = offsetX;
avatarY = offsetY + (gridSize - 1) * cellSize;

this.playerAvatar = this.add.rectangle(avatarX, avatarY, cellSize, cellSize, 0x000000);
this.playerAvatar.setOrigin(0, 0);

this.neighborSquares = this.add.group();

const avatarWidth = cellSize - 2 * padding;
const avatarHeight = cellSize - 2 * padding;

  this.hoverRectangle = this.add.rectangle(0, 0, cellSize, cellSize, 0xadd8e6, 0.3);
  this.hoverRectangle.setOrigin(0, 0);
  this.hoverRectangle.visible = false;

  this.input.on('pointermove', pointer => {
    const x = pointer.x - offsetX;
    const y = pointer.y - offsetY;
    const i = Math.floor(x / cellSize);
    const j = Math.floor(y / cellSize);
    if (i >= 0 && i < gridSize - 1 && j >= 0 && j < gridSize - 1) {
      this.hoverRectangle.x = offsetX + i * cellSize;
      this.hoverRectangle.y = offsetY + j * cellSize;
      this.hoverRectangle.visible = true;
    } else {
      this.hoverRectangle.visible = false;
    }
  });

  this.input.on('pointerdown', pointer => {
    const x = pointer.x - offsetX;
    const y = pointer.y - offsetY;
    const i = Math.floor(x / cellSize);
    const j = Math.floor(y / cellSize);
    if (i >= 0 && i < gridSize && j >= 0 && j < gridSize) {
      avatarX = offsetX + i * cellSize;
      avatarY = offsetY + j * cellSize;
    }
  });

  
}

function update(time) {
  const elapsedTime = time - lastRotationTime;

  if (elapsedTime >= 1000) {
    this.lines.forEach(line => {
      line.angle += 90;
    });

    lastRotationTime = time;
  }

  this.playerAvatar.x = avatarX;
  this.playerAvatar.y = avatarY;

  this.neighborSquares.clear(true, true);

  const i = (avatarX - (this.cameras.main.width - (gridSize * cellSize)) / 2) / cellSize;
  const j = (avatarY - (this.cameras.main.height - (gridSize * cellSize)) / 2) / cellSize;

  // Determine the direction of the lines at the avatar's current cell
  const avatarLines = getLineDirections(i, j);
  
  // Add neighbor squares
  const neighbors = [
    { x: i - 1, y: j, direction: 'W' },
    { x: i + 1, y: j, direction: 'E' },
    { x: i, y: j - 1, direction: 'N' },
    { x: i, y: j + 1, direction: 'S' }
  ];
  
  for (const neighbor of neighbors) {
    if (neighbor.x >= 0 && neighbor.x < gridSize && neighbor.y >= 0 && neighbor.y < gridSize) {
      // Determine the direction of the lines at the neighboring cell
      const neighborLines = getLineDirections(neighbor.x, neighbor.y);
      
      // Check if the lines block the neighbor
      if (!avatarLines.includes(neighbor.direction) && !neighborLines.includes(oppositeDirection(neighbor.direction))) {
        const square = this.add.rectangle(
          (this.cameras.main.width - (gridSize * cellSize)) / 2 + neighbor.x * cellSize,
          (this.cameras.main.height - (gridSize * cellSize)) / 2 + neighbor.y * cellSize,
          cellSize,
          cellSize,
          0xadd8e6
        );
        square.setOrigin(0, 0);
        this.neighborSquares.add(square);
      }
    }
  }
}

// Helper function to determine the direction of the lines at a given cell
function getLineDirections(i, j) {
  const line1 = game.scene.keys.default.lines[2 * (i * gridSize + j)];
  const line2 = game.scene.keys.default.lines[2 * (i * gridSize + j) + 1];
  const angle1 = line1.angle % 360;
  const angle2 = line2.angle % 360;
  const directions = [];
  
  if (angle1 === 0 || angle2 === 90) directions.push('N');
  if (angle1 === 90 || angle2 === 0) directions.push('E');
  if (angle1 === 180 || angle2 === 270) directions.push('S');
  if (angle1 === 270 || angle2 === 180) directions.push('W');
  
  return directions;
}

// Helper function to get the opposite direction
function oppositeDirection(direction) {
  switch (direction) {
    case 'N': return 'S';
    case 'E': return 'W';
    case 'S': return 'N';
    case 'W': return 'E';
  }
}

</script>
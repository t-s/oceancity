<script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>

<script type="text/javascript">
const minDimension = Math.min(window.innerWidth, window.innerHeight);
const cellSize = minDimension / 12; 

const gridSize = 10;
const lineLength = cellSize * 0.6;
const lineThickness = cellSize * 0.06;
const dotSize = cellSize * 0.06;
const padding = cellSize * 0.1;

let avatarX;
let avatarY;
let lastRotationTime = 0;

const config = {
  type: Phaser.AUTO,
  width: window.innerWidth,
  height: window.innerHeight,
  scene: {
    preload: preload,
    create: create,
    update: update
  }
};

const game = new Phaser.Game(config);

function preload() {
  const size = 20;
  const canvasTexture = this.textures.createCanvas('avatar', size, Math.sqrt(3) * size / 2).source[0].image;
  const context = canvasTexture.getContext('2d');
  context.beginPath();
  context.moveTo(size / 2, 0);
  context.lineTo(size, size * Math.sqrt(3) / 2);
  context.lineTo(0, size * Math.sqrt(3) / 2);
  context.closePath();
  context.strokeStyle = 'black';
  context.lineWidth = 2;
  context.stroke();
  context.fillStyle = 'yellow';
  context.fill();
}

function create() {
  this.cameras.main.setBackgroundColor('#ffffff');

  const offsetX = (this.cameras.main.width - (gridSize * cellSize)) / 2;
  const offsetY = (this.cameras.main.height - (gridSize * cellSize)) / 2;

  this.lines = [];

  for (let i = 0; i < gridSize; i++) {
  for (let j = 0; j < gridSize; j++) {
    const x = offsetX + i * cellSize;
    const y = offsetY + j * cellSize;

    const directions = ['N', 'E', 'S', 'W'];
    const direction = directions[Phaser.Math.Between(0, 3)];
    const color = new Phaser.Display.Color();
    color.random(1);

    let line1 = this.add.line(x, y, 0, 0, 0, 0, color.color).setLineWidth(lineThickness).setOrigin(0, 0.5);
    let line2 = this.add.line(x, y, 0, 0, 0, 0, color.color).setLineWidth(lineThickness).setOrigin(0, 0.5);

    switch (direction) {
      case 'N':
        line1.setTo(0, 0, 0, -lineLength);
        line2.setTo(0, 0, lineLength, 0);
        break;
      case 'E':
        line1.setTo(0, 0, lineLength, 0);
        line2.setTo(0, 0, 0, lineLength);
        break;
      case 'S':
        line1.setTo(0, 0, 0, lineLength);
        line2.setTo(0, 0, -lineLength, 0);
        break;
      case 'W':
        line1.setTo(0, 0, -lineLength, 0);
        line2.setTo(0, 0, 0, -lineLength);
        break;
    }

    this.lines.push(line1);
    this.lines.push(line2);
  }
}

  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      const x = offsetX + i * cellSize;
      const y = offsetY + j * cellSize;
      this.add.circle(x, y, dotSize, 0x000000);
    }
  }

  const padding = 10; 

avatarX = offsetX;
avatarY = offsetY + (gridSize - 1) * cellSize;

this.playerAvatar = this.add.rectangle(avatarX, avatarY, cellSize, cellSize, 0x000000);
this.playerAvatar.setOrigin(0, 0);

const avatarWidth = cellSize - 2 * padding;
const avatarHeight = cellSize - 2 * padding;

  this.hoverRectangle = this.add.rectangle(0, 0, cellSize, cellSize, 0xadd8e6, 0.3);
  this.hoverRectangle.setOrigin(0, 0);
  this.hoverRectangle.visible = false;

  this.input.on('pointermove', pointer => {
    const x = pointer.x - offsetX;
    const y = pointer.y - offsetY;
    const i = Math.floor(x / cellSize);
    const j = Math.floor(y / cellSize);
    if (i >= 0 && i < gridSize - 1 && j >= 0 && j < gridSize - 1) {
      this.hoverRectangle.x = offsetX + i * cellSize;
      this.hoverRectangle.y = offsetY + j * cellSize;
      this.hoverRectangle.visible = true;
    } else {
      this.hoverRectangle.visible = false;
    }
  });

  this.input.on('pointerdown', pointer => {
    const x = pointer.x - offsetX;
    const y = pointer.y - offsetY;
    const i = Math.floor(x / cellSize);
    const j = Math.floor(y / cellSize);
    if (i >= 0 && i < gridSize && j >= 0 && j < gridSize) {
      avatarX = offsetX + i * cellSize;
      avatarY = offsetY + j * cellSize;
    }
  });

  
}

function update(time) {
  const elapsedTime = time - lastRotationTime;

  if (elapsedTime >= 1000) {
    this.lines.forEach(line => {
      line.angle += 90;
    });

    lastRotationTime = time;
  }

  this.playerAvatar.x = avatarX;
  this.playerAvatar.y = avatarY;
}

</script>